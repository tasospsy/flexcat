############################
# Help Functions           #
############################

all.patterns <- function(J, pat){
  grid <- list()
  j <- 0;
  p <- length(pat)^J
  for (j in 1 : J){
    grid <- c(grid, j)
    grid[[j]] <- pat
  }
  X <- t(expand.grid(grid))
  dimnames(X) <- NULL
  return(X[J : 1, ])
}

# Deprecated: It is ment to use  only binary items
#readAnswer <- function(selItem){
#   repeat{
#     answer <- (readline(paste("Item ", selItem, ". Please, answer 0 or 1. ", sep = "")))
#     if(answer %in% 0 : 1) break
#     cat("PLEASE, answer 0 or 1", fill = TRUE)
#   }  
#   return(as.numeric(answer) + 1L)
#}

computePY.ro <- function(J, R, RP, Y, YR, obsPattern, obsPatternScore, iter){
   PY <- rep(NA, length(Y))
   if (iter == 0) for (y in Y) PY[y + 1] <- sum(RP[YR == y])  
   if (iter == 1) for (y in Y) PY[y + 1] <- sum(RP[YR == y & R[, obsPattern] == obsPatternScore[, obsPattern]]) 
   if (iter > 1)  for (y in Y) PY[y + 1] <- sum(RP[YR == y & apply(R[, obsPattern] == obsPatternScore[, obsPattern], 1, all)])  
   return(PY / sum(PY))
}

# Deprecated: it is a special case of computePY.ro
#computePS.ro <- function(J, R, RP, S, SR, obsPattern, obsPatternScore, iter){
#   PS <- rep(NA, length(S))
#   if (iter == 0) for (s in S) PS[s + 1] <- sum(RP[SR == s])  
#   if (iter == 1) for (s in S) PS[s + 1] <- sum(RP[SR == s & R[, obsPattern] == obsPatternScore[, obsPattern]]) 
#   if (iter > 1)  for (s in S) PS[s + 1] <- sum(RP[SR == s & apply(R[, obsPattern] == obsPatternScore[, obsPattern], 1, all)])  
#   return(PS / sum(PS))
#}

computePY.rox <- function(J, R, RP, Y, YR, obsPattern, obsPatternScore, iter){
  PY.rox <- list()
  nY <- length(Y) 
  nCat <- max(R) 
  for (j in 1L : J){ 
    PY.rox[[j]] <- matrix(NA, nY, nCat)
    if(isFALSE(obsPattern[j])){ 
      tmpObsPattern <- obsPattern
      tmpObsPattern[j] <- TRUE
      for (x in 1L : nCat){
        tmpObsPatternScore <- obsPatternScore
        tmpObsPatternScore[, j] <- x  
        PY.rox[[j]][, x] <- computePY.ro(J, R, RP, Y, YR, tmpObsPattern, tmpObsPatternScore, iter + 1)  
      }
    }
  }    
  return(PY.rox)
}
## which correct? !! SOS
computePY.rox <- function(J, nCat, R, RP, Y, YR, obsPattern, obsPatternScore, iter){
  PY.rox <- list()
  nY <- length(Y) 
  for (j in 1L : J){ 
    PY.rox[[j]] <- matrix(NA, nY, nCat)
    if(isFALSE(obsPattern[j])){ 
      tmpObsPattern <- obsPattern
      tmpObsPattern[j] <- TRUE
      for (x in 1L : nCat){
        tmpObsPatternScore <- obsPatternScore
        tmpObsPatternScore[, j] <- x-1 # -1 added to work with R(0,1)
        PY.rox[[j]][, x] <- computePY.ro(J, R, RP, Y, YR, tmpObsPattern, tmpObsPatternScore, iter + 1)  
      }
    }
  }
  return(PY.rox) 
}


# Deprecated: it is a special case of computePY.rox
#computePS.rox <- function(J, R, RP, S, SR, obsPattern, obsPatternScore, iter){
#   PS.rox <- list()
#   nS <- length(S) 
#   nCat <- max(R) 
#   for (j in 1L : J){ 
#      PS.rox[[j]] <- matrix(NA, nS, nCat)
#      if(isFALSE(obsPattern[j])){ 
#         tmpObsPattern <- obsPattern
#         tmpObsPattern[j] <- TRUE
#         for (x in 1L : nCat){
#             tmpObsPatternScore <- obsPatternScore
#             tmpObsPatternScore[, j] <- x  
#             PS.rox[[j]][, x] <- computePS.ro(J, R, RP, S, SR, tmpObsPattern, tmpObsPatternScore, iter + 1)  
#         }
#      }
#   }    
#   return(PS.rox) 
#}


computePXi.ro <- function(J, R, RP, obsPattern, obsPatternScore, iter){
   PXi <- matrix(NA, J, nCat)
   if (iter == 0) for (j in 1 : J) for (x in 1 : nCat) PXi[j, x] <- sum(RP[R[, j] == x])  
   if (iter == 1) for (j in 1 : J) for (x in 1 : nCat) PXi[j, x] <- ifelse(obsPattern[j], ifelse(obsPatternScore[1, j] == x, 1, 0), sum(RP[R[, j] == x & R[,  obsPattern] == obsPatternScore[, obsPattern]]))
   if (iter > 1)  for (j in 1 : J) for (x in 1 : nCat) PXi[j, x] <- ifelse(obsPattern[j], ifelse(obsPatternScore[1, j] == x, 1, 0), sum(RP[R[, j] == x & apply(R[, obsPattern] == obsPatternScore[, obsPattern], 1, all)]))
   return(PXi / apply(PXi, 1, sum, na.rm = TRUE))
}
## ?! v2:
computePXi.ro <- function(J, nCat, R, RP,obsPattern, obsPatternScore, iter){
  PXi <- matrix(NA, J, nCat)
  if (iter == 0) for (j in 1 : J) for (x in 1 : nCat) PXi[j, x] <- sum(RP[R[, j] == x-1])  
  if (iter == 1) for (j in 1 : J) for (x in 1 : nCat) PXi[j, x] <- ifelse(obsPattern[j], ifelse(obsPatternScore[1, j] == x - 1, 1, 0), sum(RP[R[, j] == x - 1 & R[,  obsPattern] == obsPatternScore[, obsPattern]]))
  if (iter > 1)  for (j in 1 : J) for (x in 1 : nCat) PXi[j, x] <- ifelse(obsPattern[j], ifelse(obsPatternScore[1, j] == x - 1, 1, 0), sum(RP[R[, j] == x - 1 & apply(R[, obsPattern] == obsPatternScore[, obsPattern], 1, all)]))
  return(PXi / apply(PXi, 1, sum, na.rm = TRUE))
}

#computeInaccurate <- function(J, R, RP, S, SR, obsPattern, obsPatternScore, iter){
#   PS <- rep(NA, J + 1)
#   if (iter == 0) for (s in S) PS[s + 1] <- sum(RP[SR == s])  
#   if (iter == 1) for (s in S) PS[s + 1] <- sum(RP[SR == s & R[, obsPattern] == obsPatternScore[, obsPattern]]) 
#   if (iter > 1)  for (s in S) PS[s + 1] <- sum(RP[SR == s & apply(R[, obsPattern] == obsPatternScore[, obsPattern], 1, all)])  
#   return(sum(PS))  
#}

 doVerbose <- function()   
 # FUNCTION USES GLOBAL VARIABLES ONLY
   cat("Observed response pattern: ", obsPatternScore[1, ] - 1L, 
      "\nProbability of observed response patters", round(inaccurate, 6), 
      "\nNumber of items used", sum(obsPattern), 
      "\nNumber of items not used", J - sum(obsPattern), 
      "\nExpected total score: ", EX.ro * J, 
      "\nConfidence Interval [", round(CI.ro[1], 2), "-", round(CI.ro[2], 2), "]",
      "\nEfficiency", round((J - sum(obsPattern)) / J * 100, 1), "%", 
      fill = TRUE)

entropy <- function(r, rp, sr, s, sp, op, ops, nCat = 2){
  J <- ncol(r)
  EX <- matrix(NA, J, nCat)
  for (j in 1 : J) for (i in 1 : nCat) if (!op[j]){
      tmpOp  <- op
      tmpOp[j] <- TRUE  
      tmpOps <- ops
      tmpOps[, j] <- i
      tmpSp  <- sp
      if (all(is.na(ops))) {
         for (h in s) tmpSp[h + 1] <- sum(rp[sr == h & r[, tmpOp] == tmpOps[, tmpOp]]) 
      } else {
         for (h in s) tmpSp[h + 1] <- sum(rp[sr == h & apply(r[, tmpOp] == tmpOps[, tmpOp], 1, all)])  
      }
      tmpSp <- tmpSp / sum(tmpSp)
      EX[j, i] <- sum(tmpSp * s)
    }
    return(EX[, 2] - EX[, 1])
}

displayCat <- function(S, SP, e, sel, minProb = .01){
   J <- length(e) 
   par(mfrow = c(1, 2))
   plot(S, SP/sum(SP), xlim = c(0, J), ylim = c(0, 1), type = "l", xlab = "Sum score", ylab = "Probability")
   points(S[SP == max(SP)], max(SP)/sum(SP), pch = 19, col = "red")
   if (!is.na(sel)) plot(1 : J, e,  ylim = c(0, max(e, na.rm = TRUE)), type= "p", xlab = "Item", ylab = "Delta")
   if (!is.na(sel))points(sel, e[sel], pch = 19, col = "red")
} 


## Display CAT for live administration (Tasos)
displayCatT.adm <- function(S, SP, e, sel, minProb = .01){
  J <- length(e)
  par(mfrow = c(1, 2))
  # π+ plot:
  #plot(S, SP/sum(SP),  ylim = c(0, 1), type = "l", xlab = "Sum score", ylab = "Probability", xaxt="n")
  #axis(1, at=S, labels=S) # all x vaklues
  #points(S[SP == max(SP)], max(SP)/sum(SP), pch = 19, col = "red")
  # prediction plot:
  barplot(SP,  names.arg = paste(S), ylim = c(0, 1), xlab = "Categories", ylab = "Probability", 
          main = paste0('\n Administered Items: ',iter))
  abline(h = prec, col = "red", lty = 2, lwd = 1)
  # delta plot:
  if (!is.na(sel)) {
    plot(1 : J, e,  ylim = c(0, max(e, na.rm = TRUE)), type= "p", xlab = "Item", ylab = "Information",xaxt="n",
         main = paste0("Next item to be administered\n is item number ", selItem ))
    axis(1, at=1:J, labels=1:J)
    points(sel, e[sel], pch = 19, col = "red")
    points(which(e == 0), e[which(e == 0)], pch = 19, col = "green")
  }
}

## Verbose for live administration (Tasos)
doVerboseT.adm <- function()   {
  cat(#"\nPerson:", person, "/", M,
    "\nObserved response pattern: ", obsPatternScore[1, ],  ## REMOVE 1L !
    "\nNumber of items used", sum(obsPattern),'/', J, 
    #"\nExpected total score (SE): ", EX.ro," (",SE.ro,")", 
    #"\nConfidence Interval [", round(CI.ro[1], 2), "-", round(CI.ro[2], 2), "]",
    "\nEfficiency", round((J - sum(obsPattern)) / J * 100, 1), "%", 
    #"\nmax(π+):", round(max(PS.ro),2),
    "\nEligibility Probability:",PY.ro," (user specified criterion = ",precisionCriterion,")", 
    "# -------------------------------------------------------------------------\n",
    fill = TRUE)
}
############################
# estimateLcm              #
############################

estimateLcm <- function(X, ic = "aic", method = "all", saveLCMparams = FALSE){

  # This function first fits a LCM usin <- g poLCA:: and keeps the best fitting model according to a specified IC
  # Then, computes the item-score density (π) under one of 3 choices: "mod", "emp", and "all)
  ############################
  # Preliminaries
  # J = number of items
  # ic = information criterion: "aic", "aic3", "aicc", "bic"
  # nCat = number of categories
  # Checks of class, missing values and item scores

  J <- ncol(X)          
  nCat <- max(X) - min(X) + 1L
  
  if(!is.data.frame(X)) stop('X is not a data.frame')
  if(any(is.na(X))) stop('Some item scores are missing')
  #if(!all(unlist(X) %in% 1:2)) stop('Data contain item scores other than 1 and 2')
  
  ############################
  # Estimating the latent class model
  f <- as.formula(paste0('cbind(',paste(names(X), collapse=','),')~1'))
  #f <- as.formula(paste("cbind(",paste(names(X)[1 : (J - 1)], "," , sep = "",collapse = ""), paste(names(X)[J], sep=""),") ~ 1", collapse=""))
  K <- 0L  
  bestFit <- fit <- 1e100
  bestK <- 0
  model.fit <- list(AIC = rep(NA, 100), AICc = rep(NA, 100), AIC3 = rep(NA, 100), BIC = rep(NA, 100))
  
  X1 <- X - min(X) + 1L # if [0:..] transforms it to [1:...] for polca, else nothing happens and X1 = X
  repeat{
    K <- K + 1L
    cat('-> Estimating uLCM(',K,') at', format(Sys.time(), "%H:%M \n"))
    model.lc <- poLCA(f, X1, nclass = K, maxiter = 5000)
    model.fit$AIC[K] <- model.lc$aic 
    model.fit$AICc[K] <- model.lc$aic + (2 * model.lc$npar * (model.lc$npar + 1)) / (model.lc$Nobs - model.lc$npar - 1)
    model.fit$AIC3[K] <- -2 * model.lc$llik + 3 * model.lc$npar
    model.fit$BIC[K] <- model.lc$bic
    icNumber <- ifelse(sum(c("aic", "aicc", "aic3", "bic") %in% ic) != 1, 1, which(c("aic", "aicc", "aic3", "bic") %in% ic))
    #icNumber <- ifelse (ic %in% c("aic", "aicc", "aic3", "bic"), which(c("aic", "aicc", "aic3", "bic") == ic),1)
    fit <- model.fit[[icNumber]][K] 
    if(fit < bestFit){
      bestFit <- fit
      bestK <- K  
      bestModel <- model.lc
    }
    if (K == bestK + 2) break
  }
     
  ############################
  # Output of the latent class model
  # W are the class weights P(C = k)
  # P are the conditional response probabilities P(Xj = x|C = k): a K * nCat matrix for each item

  W <- bestModel$P
  P <- bestModel$probs

  ############################
  # Managing the output of the latent class model
  # nR <- nCat^J is the number of possible response patters. If J is large, nR may become infeasibly large
  # R is an nR x J matrix of all response patterns
  # Because the number of rows may be too large, several row-reduction methods  have been added: "emp" (empirical), "mod" (model based)
  # RP is an nR x 1 vector of the probability that a response patterns occurs under the latent class model
  # Note: R is based on X1, the dataset used for poLCA
  if (method == "all") R <- t(all.patterns(J, 1 : nCat))
  
  if (method == "emp") {
         Rchar <- matrix(sort(unique(apply(X1, 1, paste0, collapse = ""))))
         R <- t(sapply(Rchar[,1], function(s) as.numeric(strsplit(s, "")[[1]])))
  }
  if (method == "mod") { 
         Nsim <- 10000                                                                                     # Number of simulees
         Ksim <- sample(1:bestK, Nsim, TRUE, prob= W)                                                      # Classes of the simulees 
         Psim <- lapply(Ksim, function(n) do.call(rbind, lapply(P, function(mat) mat[n, , drop = FALSE]))) # Response probablities of the simulees 
         Psim <- lapply(Psim, function(x) t(apply(x, 1, cumsum)))                                          # Cumulative response probablities of the simulees  
         Usim <- lapply(1:Nsim, function(r) matrix(runif(J), nrow = J, ncol = nCat, byrow = FALSE))        # Random numbers
         PgtU <- mapply(function(p, u) (p >= u) * 1, Psim, Usim, SIMPLIFY = FALSE)                         # Compare Cum resp probabilities to random numbers 
         Xsim <- matrix(unlist(lapply(PgtU, function(x) apply(x, 1, sum))), Nsim, J, byrow = TRUE)         # Simulated item score data
         Rchar <- matrix(sort(unique(apply(Xsim, 1, paste0, collapse = ""))))                                 # see "emp"
         R <- t(sapply(Rchar[,1], function(s) as.numeric(strsplit(s, "")[[1]])))                           # see "emp"
  }          
  nR <- nrow(R)
  RP <- rep(NA, nR)
  for (p in 1 : nR){ 
    RP[p] <- 0
    for (k in 1 : bestK){
       RP.k <- log(W[k]) 
       for(j in 1 : J) RP.k <- RP.k + log(P[[j]][k, R[p, j]])
       RP[p] <- RP[p] + exp(RP.k)        
    }
  }
  RP <- RP/sum(RP) # normalize π
  
  # return the data to original format
  if(min(X1)-min(X)==1) R <- R - 1L 
  result <- list(X = X, R = R, RP = RP, nCat = nCat, K = bestK)
  
  if (saveLCMparams) {
    result$W <- W
    result$P <- P
  }
  return(result)
}


# Tasos 'g' function for creating outcome categories ----------------------
#  It uses the estimateLcm() output 
# intervals: The user specifies the thresholds as a list of sequences 
# e.g. for PHQ9 if sumscore > 9 is depressed then #intervals = list(0:9, 10:27)

scores <- function(intervals, #intervals = list(0, 1:27), #the classification groups manually defined (if sumscore = as.list(S))
                   estimateLcm_output){
  R <- estimateLcm_output$R
  sr <- apply(R, 1, sum) # small letters because it is silent; we dont need it elsewhere
  RP <- estimateLcm_output$RP
  # Tasos' Q ---------------------------------------------------------
  n_groups <- length(intervals)
  nR <- nrow(R)
  Q <- matrix(0, nrow = nR, ncol = n_groups)
  for (i in 1:nR) {
    for (group in 1:n_groups) {
      if (sr[i] %in% intervals[[group]]) {
        Q[i, group] <- 1
        break
      }
    }
  }
  YR <- matrix(apply(Q, 1, function(x)
    which(x > 0)) - 1)
  Y <- sort(unique(YR)) #unique outcome responses
  #rm(Q, sr)
  Py <- rep(NA, length(Y)) # after 
  for (y in Y) Py[y + 1] <- sum(RP[YR == y])
  return(list(YR = YR, Y = Y, Py = Py))
}

g <- function(x, intervals) {
  s <- apply(x, 1, sum) 
  y <- rep(NA, length(s))  
  for (group in seq_along(intervals)) {
    y <- ifelse(s %in% intervals[[group]], group - 1, y)  # Assign group index (0-based)
  }
  return(y)
}

#g <- function(x) {s <- apply(x, 1, sum); y <- rep(NA, length(s)); y <- ifelse(s <= 10, 0, y);y <- ifelse(s > 10, 1, y); return(y)} 
#g <- function(x) {s <- apply(x, 1, sum)} 

# Tasos has not checked the functions below
############################
# lcaCat                   #
############################
lcaCat <- function(resultsLcm, newScores, nItems = nItemsDefault, precision = precisionDefault, inaccurateCriterion = inaccurateDefault) {
stop('does not yet work. Should be adapted according to cat3.R')
# The function uses the results from the latent class analysis
# * resultsLcm is a list with components
#   X : an N x J data.frame passed on by estimateLcm
#   R : an R x J matrix all possible item-score vectors
#   SR: an R x 1 vectors containing the sum score for  each item-score vector
#   RP: an R x 1 vectors containing the probability of each item-score vector
# * inaccurateCriterion is criterion value. If the probability that an observed response patters is
#   less than inaccurate, a warning is provided that the response pattern is an outlier and
#   results should not be trusted. Default value: .001^J
# * precision is a criterion value. If the standard error of the sum score is less than precision,
#   the procedure stops
#  nR: number of item-score vectors
#  N: number of respondents
#  J: number of items
#  nCat: number of categories FOR NOW confined to 2
#  inaccurate: see above
#  precision: see above. FOR NOW it is the probability of obtaining a certain total score.

 X <- resultsLcm$X
 R <- resultsLcm$R
 SR <- resultsLcm$SR
 RP <- resultsLcm$RP
 nR <- nrow(R)
 N <- nrow(X)
 J <- ncol(X)
 nCat <- max(X) - min(X) + 1
 nItemsDefault <- J
 precisionDefault <- 1
 inaccurateDefault <- .001^J
 A <- newScores
 M <- nrow(A)

############################
# Starting the CAT
# iter: iteration
# obsPattern: A J x 1 vector indicating whether an item has been administered to a testee (starts with all FALSE)
# obsPatternScore: An NR x J matrix containing the item scores of the testee. At the start all elements are NA
#   if a score on item j has been obtained, the jth column is set to that score
# S      : possible sumscores 0, 1, 2, ..., J
# PS.ro  : probability distribution of the sum score given the responses so far
# PXi.ro : probability distributions of the item scores given the responses so far
# EX.ro  : Expected sum score (scaled from 0 to 1) given the responses so far
# EX.rox : Expected sum score (scaled from 0 to 1) given the responses so far, and the outcome of a pivot item
# delta  : Information type measure: Higher is better
# selItem : the item selected to be administered: The item has not yet been administered and has the highest delta
# inaccurate : probability of the observed item-score vector

 person <- 1L
 results <- list()
 for (person in 1L : M){
   startTime <- Sys.time()
   results[[person]] <- list()

   iter <- 0L
   obsPattern <- rep(FALSE, J)
   obsPatternScore <- matrix(NA, nR, J)
   S <- 0L : J

   PS.ro   <- computePS.ro(J, R, RP, obsPattern, obsPatternScore, iter)
   PXi.ro  <- computePXi.ro(J, R, RP, obsPattern, obsPatternScore, iter)
   EX.ro   <- computeEX.ro(PXi.ro)
   EX.rox  <- computeEX.rox(PXi.ro, obsPattern)
   delta <- apply(PXi.ro * abs(EX.ro - EX.rox), 1, sum)
   selItem <- which.max(delta)
   # inaccurate <- computeInaccurate(J, R, RP, S, SR, obsPattern, obsPatternScore, iter)
   # displayCat(S, PS.ro, delta, selItem)

   repeat{
      iter <- iter + 1L
      obsPattern[selItem] <- TRUE
      obsPatternScore[, selItem] <- A[person, selItem] + 1 # PLUS 1 vanwege polCAA??
      PS.ro   <- computePS.ro(J, R, RP, S, SR, obsPattern, obsPatternScore, iter)
      PXi.ro  <- computePXi.ro(J, R, RP, obsPattern, obsPatternScore, iter)
      EX.ro   <- computeEX.ro(PXi.ro)
      EX.rox  <- computeEX.rox(PXi.ro, obsPattern)
      SE.ro   <- sqrt(sum(PS.ro * (S - EX.ro * J)^2))
      # CI.ro   <- c(EX.ro * J - 1.96 * SE.ro, EX.ro * J + 1.96 * SE.ro)
      delta <- apply(PXi.ro * abs(EX.ro - EX.rox), 1, sum)
      selItem <- which.max(delta)
      # inaccurate <- computeInaccurate(J, R, RP, S, SR, obsPattern, obsPatternScore, iter)
      # if (inaccurate < inaccurateCriterion) warning("Abberant response pattern; CAT may be inaccurate")
      # displayCat(S, PS.ro, delta, selItem)
      # doVerbose()
      # if(iter == nItems | sum(S < CI.ro[2] & S > CI.ro[1]) < 2) break
      if(iter == nItems | max(PS.ro) > precision) break
   }
   endTime <- Sys.time()
   results[[person]]$actualItemcores   <- A[person, ]
   results[[person]]$actualSumscore    <- sum(A[person, ])
   results[[person]]$usedItemscores    <- obsPatternScore[1, ] - 1L
   results[[person]]$expectedSumscore  <- round(EX.ro * J)
   # results[[person]]$ci                <- c(EX.ro * J - 1.96 * SE.ro, EX.ro * J + 1.96 * SE.ro)
   results[[person]]$efficiency        <- round((J - sum(obsPattern)) / J * 100, 1)
   results[[person]]$time              <- as.numeric(endTime - startTime, unit = "secs")
   print(round(person / M * 100, 1)); Sys.sleep(.01); flush.console()
 }
 return(results)
}
####################
#  Stay 9          #
####################
stay9 <- function(x) apply(outer((x - mean(x)) / sd(x), seq(-1.75, 1.75, .5), ">"), 1, sum) + 1

####################
#  showOutput      #
####################

 showOutput <- function(x) {

 nC <- length(x)
 M <- lengths(x)

 y <- list()
 for (g in 1 : nC){ 
   difference <- efficiency <- actualSumScore <- expectedSumScore <- actualSta9 <- expectedSta9 <- theTime <- rep(NA, M[g])
   for (n in 1 : M[g]){
     efficiency[n] <- x[[g]][[n]]$efficiency
     actualSumScore[n] <- x[[g]][[n]]$actualSumscore
     expectedSumScore[n] <- x[[g]][[n]]$expectedSumscore
     theTime[n] <- x[[g]][[n]]$time
   }
   difference <- actualSumScore - expectedSumScore
   tableDifference <- round(c(length(difference[difference == 0])/M[g], length(difference[difference == 1 | difference == -1])/M[g], length(difference[difference > 1 | difference < -1])/M[g]), 2)
   actualStay9 <- stay9(actualSumScore)
   expectedStay9 <- stay9(expectedSumScore)
   difference9 <- actualStay9 - expectedStay9
   tableDifference9 <- round(c(length(difference9[difference9 == 0])/M[g], length(difference9[difference9 == 1 | difference9 == -1])/M[g], length(difference9[difference9 > 1 | difference9 < -1])/M[g]), 2)
   names(tableDifference) <- names(tableDifference9) <- c("0", "1", ">1")
   y[[g]] <- list(efficiency = efficiency, time = theTime, tableAccuracy = tableDifference9, accuracy = difference9, correlation = cor(actualSumScore, expectedSumScore))
 }
 names(y) <- names(x)
 return(y)
}

